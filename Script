/******************************************************************
 *  MASTER PIPELINE SCRIPT  v 7.0  (2025-07-11)
 *  --------------------------------------------------------------
 *  • Extractions audit override block AA-AF (stable)
 *  • Solutions audit override block U-Z (Y & Z fully preserved)
 *  • Header-safe, hidden-safe overwriteSheet
 *  • Checkbox → full name (AD→AE, X→Z)
 *  • 50 000-char truncator to avoid cell-length errors
 ******************************************************************/

/* ---------- GLOBAL CONSTANTS ---------- */
const MAX_CELL_LENGTH = 50000;
const truncateValue  = v =>
  (typeof v === 'string' && v.length > MAX_CELL_LENGTH) ? v.slice(0, MAX_CELL_LENGTH) : v;
const truncateMatrix = m => m.map(r => r.map(truncateValue));

/* ---------- CONFIG ---------- */
const CFG = {
  /* Extractions */
  CONNECTED_SHEET   : 'All Problems in Solutions - Ext',
  PENDING_SHEET     : 'Completed Extractions',
  CLEANED_SHEET     : 'Completed Extractions - Cleaned',
  AUDIT_RAW_SHEET   : 'Completed Extractions -> Audit (RAW)',
  AUDIT_VIEW_SHEET  : 'Completed Extractions -> Audit for delivery',
  SOLN_SHEET        : 'Completed Extractions -> Solutions',
  HOLD_SHEET        : 'Completed Extractions -> Holding',

  /* Solutions */
  SOL_PENDING_SHEET : 'Approved and Completed Solutions - Ext',
  SOL_ALL_SHEET     : 'Delivered Solutions - Ext',
  SOL_CLEANED_SHEET : 'Approved and Completed Solutions - Cleaned',
  SOL_AUDIT_SHEET   : 'Clean Solutions Audit',
  SOL_PAUSE_SHEET   : 'Solutions -> Pause',

  /* Shared */
  ALL_ID_COLS       : ['original_task_id', 'problem_id'],
  PENDING_ID_COLS   : ['task_id', 'problem_id'],
  TEXT_COL          : 'problem',

  /* Other */
  SIM_THRESHOLD     : 0.90                // cosine/Jaccard similarity cut
};

/* ---------- MENU ---------- */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Task Tools')
    .addItem('Run Completed Extractions Pipeline', 'runAllExtractions')
    .addItem('Run Approved & Completed Solutions Pipeline', 'runSolutions')
    .addToUi();
}

/* ---------- REFRESH ---------- */
function refreshConnectedData() {
  SpreadsheetApp.enableBigQueryExecution();
  SpreadsheetApp.getActiveSpreadsheet().refreshAllDataSources();
  SpreadsheetApp.flush();
}

/* =========================================================== */
/*  SHARED LOW-LEVEL HELPERS                                    */
/* =========================================================== */
/**
 * overwriteSheet
 *  • Clears rows 2↓ only in the script-owned columns
 *  • Rewrites row 1 header for all script columns
 *  • Writes fresh data only through the last owned column
 *  • Restores hidden sheets to hidden state
 *
 * @param {SpreadsheetApp.Spreadsheet} ss
 * @param {string}  name      Target sheet name
 * @param {string[]} headers   Header row the script owns
 * @param {any[][]} rows       Data rows to write
 */
function overwriteSheet(ss, name, headers, rows) {
  const sh = ss.getSheetByName(name) || ss.insertSheet(name);
  const wasHidden = sh.isSheetHidden();

  /* Decide how many columns we OWN (everything left of manual overrides) */
  let owned = headers.length;               // default (e.g. Cleaned sheets)

  if (name === CFG.AUDIT_VIEW_SHEET) owned = 25; // A…Y   (leave AA-AF intact)
  if (name === CFG.SOL_AUDIT_SHEET)  owned = 20; // A…T   (leave U-Z intact)

  /* 1⃣  Clear existing rows in OWNED columns only */
  const curRows = sh.getMaxRows();
  if (curRows > 1) {
    sh.getRange(2, 1, curRows - 1, owned).clearContent();
  }

  /* 2⃣  Rewrite header row (A…headers.length) */
  sh.getRange(1, 1, 1, headers.length)
    .setValues([truncateMatrix([headers])[0]]);

  /* 3⃣  Spill NEW data into A…OWNED  ← **patch is here** */
  if (rows.length) {
    const trimmed = rows.map(r => r.slice(0, owned)); // cut to owned width
    sh.getRange(2, 1, trimmed.length, owned)
      .setValues(truncateMatrix(trimmed));
  } else {
    sh.getRange(2, 1).setValue('No rows');
  }

  /* 4⃣  Freeze header & restore hidden state */
  sh.setFrozenRows(1);
  if (wasHidden) sh.hideSheet();
}


function writeRaw(ss, name, headers, rows) {
  const raw = ss.getSheetByName(name) || ss.insertSheet(name);
  raw.clearContents();
  if (rows.length) {
    raw.getRange(1, 1, 1, headers.length).setValues([truncateMatrix([headers])[0]]);
    raw.getRange(2, 1, rows.length, headers.length).setValues(truncateMatrix(rows));
  }
  raw.hideSheet();
}

/* Token / similarity helpers */
const canonical=t=>String(t||'').trim().toLowerCase()
  .replace(/’/g,"'").replace(/[“”]/g,'"')
  .replace(/\u2212/g,'-').replace(/\xa0/g,' ')
  .replace(/[^\w\s]/g,' ').replace(/\s+/g,' ');
const tokens=t=>canonical(t).split(' ').filter(w=>w.length>=3);
const norm   =v=>{const s=String(v??'').trim(); return s&&!/^(null|n\/?a)$/i.test(s)?s:'';};
const jaccard=(A,B)=>{const a=new Set(A),b=new Set(B);const i=[...a].filter(x=>b.has(x)).length;return i/(a.size+b.size-i||1);};
const truthy =v=>v===true||v==='TRUE'||v==='true';

/* =========================================================== */
/* ① COMPLETED EXTRACTIONS PIPELINE                             */
/* =========================================================== */
function runAllExtractions() {
  refreshConnectedData();
  cleanCompletedExtracts();
  syncOverrides();                         // AA-AF
  SpreadsheetApp.getUi().alert('✅ Completed Extractions pipeline complete!');
}

function cleanCompletedExtracts() {
  const ss = SpreadsheetApp.getActive();

  /* Corpus of *all* Solutions problems */
  const corpus = loadCorpus(
    ss.getSheetByName(CFG.CONNECTED_SHEET),
    CFG.ALL_ID_COLS,
    CFG.TEXT_COL
  );
  const corpusIds = new Set(corpus.flatMap(c=>[c.id1,c.id2]).filter(Boolean));
  const corpusTok = corpus.map(c=>c.tok);

  /* Pending Extractions */
  const pSh = ss.getSheetByName(CFG.PENDING_SHEET);
  const V   = pSh.getDataRange().getValues(), H = V[0], R = V.slice(1);
  const i   = { task:H.indexOf('task_id'),
                pid :H.indexOf('problem_id'),
                txt :H.indexOf('problem'),
                prob:H.indexOf('problematic_task'),
                agree:H.indexOf('model_solution_agreement') };

  const HEAD=[...H,'is_exact_duplicate_id','matching_ids','is_near_duplicate','nearest_task_id','similarity'];
  const out=[];
  R.forEach(r=>{
    const matches=[], tID=norm(r[i.task]), pID=norm(r[i.pid]);
    if(tID&&corpusIds.has(tID)) matches.push(tID);
    if(pID&&corpusIds.has(pID)) matches.push(pID);
    const exact=matches.length>0;

    const tok=tokens(r[i.txt]);
    let best=0,bI=-1;
    corpusTok.forEach((t,idx)=>{const s=jaccard(tok,t); if(s>best){best=s;bI=idx;}});
    const near=best>=CFG.SIM_THRESHOLD;
    const nearest=near?corpus[bI].id1:'';

    out.push([...r, exact, matches.join(','), near, nearest, best.toFixed(3)]);
  });

  overwriteSheet(ss, CFG.CLEANED_SHEET, HEAD, out);

  /* Partition */
  const iExact=HEAD.indexOf('is_exact_duplicate_id'),
        iNear =HEAD.indexOf('is_near_duplicate'),
        iProb =HEAD.indexOf('problematic_task'),
        iAgree=HEAD.indexOf('model_solution_agreement');
  const audit=[], soln=[], hold=[];
  const OK="No issues with task!";
  out.forEach(r=>{
    const dup=truthy(r[iExact])||truthy(r[iNear]);
    const good=String(r[iProb]).trim()===OK;
    const agree=String(r[iAgree]).trim()==='Yes';
    if(good && !dup && agree) audit.push(r);
    else if(good && !dup)     soln.push(r);
    else                      hold.push(r);
  });

  writeRaw      (ss, CFG.AUDIT_RAW_SHEET, HEAD, audit);
  ensureAuditView(ss, HEAD);
  overwriteSheet(ss, CFG.SOLN_SHEET, HEAD, soln);
  overwriteSheet(ss, CFG.HOLD_SHEET, HEAD, hold);
}

/* AA-AF override realignment */
function syncOverrides() {
  const sh=SpreadsheetApp.getActive().getSheetByName(CFG.AUDIT_VIEW_SHEET);
  if(!sh) return;
  const n=sh.getLastRow()-1; if(n<1) return;
  const old=sh.getRange(2,27,n,6).getValues();   // AA-AF
  const map=new Map(); old.forEach(r=>{const k=String(r[0]).trim();if(k)map.set(k,r)});
  const id = sh.getRange(2,1,n).getValues(),
        pr = sh.getRange(2,2,n).getValues(),
        cp = sh.getRange(2,13,n).getValues(),
        mp = sh.getRange(2,17,n).getValues();
  const blk=[];
  for(let i=0;i<n;i++){
    const key=String(id[i][0]).trim(), prev=map.get(key)||Array(6).fill('');
    blk.push([
      key,
      prev[1]||(cp[i][0]&&String(cp[i][0]).trim().toUpperCase()!=='N/A'?cp[i][0]:pr[i][0]),
      prev[2]||mp[i][0],
      prev[3]||'', prev[4]||'', prev[5]||''
    ].map(truncateValue));
  }
  sh.getRange(2,27,n,6).setValues(blk);
}

/* Show/hide audit view */
function ensureAuditView(ss,HEAD){
  const n=HEAD.length,
        view=ss.getSheetByName(CFG.AUDIT_VIEW_SHEET)||ss.insertSheet(CFG.AUDIT_VIEW_SHEET);
  view.getRange(1,1,1,n).setValues([truncateMatrix([HEAD])[0]]);
  view.getRange(2,1,view.getMaxRows()-1,n).clearContent();
  const esc=CFG.AUDIT_RAW_SHEET.replace(/'/g,"''");
  view.getRange('A2').setFormula(`=FILTER('${esc}'!A2:${String.fromCharCode(64+n)},LEN('${esc}'!A2:A))`);
  view.setFrozenRows(1); view.hideSheet();
}

/* =========================================================== */
/* ② APPROVED & COMPLETED SOLUTIONS PIPELINE                    */
/* =========================================================== */
function runSolutions() {
  refreshConnectedData();
  cleanApprovedCompletedSolutions();
  syncSolutionsOverrides();            // U-Z
  SpreadsheetApp.getUi().alert('✅ Approved & Completed Solutions pipeline complete!');
}

function cleanApprovedCompletedSolutions() {
  const ss=SpreadsheetApp.getActive();

  /* corpus */
  const all=loadCorpus(
    ss.getSheetByName(CFG.SOL_ALL_SHEET),
    ['task_id','problem_id'],
    CFG.TEXT_COL
  );
  const ids=new Set(all.flatMap(c=>[c.id1,c.id2]).filter(Boolean));
  const tokArr=all.map(c=>c.tok);

  /* pending */
  const pSh=ss.getSheetByName(CFG.SOL_PENDING_SHEET);
  const V=pSh.getDataRange().getValues(), H=V[0], R=V.slice(1);
  const ix={task:H.indexOf('task_id'), pid:H.indexOf('problem_id'),
            ext:H.indexOf('extracted_problem'),
            sol:H.indexOf('annotator_solution'),
            cor:H.indexOf('corrected_problem'),
            flag:H.indexOf('problematic_task')};

  const HEAD=[...H,'is_exact_duplicate_id','matching_ids','is_near_duplicate','nearest_task_id','similarity'];
  const pending=[];
  R.forEach(r=>{
    const matches=[], tID=norm(r[ix.task]), pID=norm(r[ix.pid]);
    if(tID&&ids.has(tID)) matches.push(tID);
    if(pID&&ids.has(pID)) matches.push(pID);
    const exact=matches.length>0;

    const tok=tokens(r[ix.ext]), sims=tokArr.map(t=>jaccard(tok,t));
    const best=Math.max(...sims), bestI=sims.indexOf(best);
    const near=best>=CFG.SIM_THRESHOLD, nearest=near?all[bestI].id1:'';

    pending.push([...r,exact,matches.join(','),near,nearest,best.toFixed(3)]);
  });

  overwriteSheet(ss, CFG.SOL_CLEANED_SHEET, HEAD, pending);

  /* partition */
  const iExact=HEAD.indexOf('is_exact_duplicate_id'),
        iNear =HEAD.indexOf('is_near_duplicate'),
        iFlag =HEAD.indexOf('problematic_task');
  const OK="No issues with problem! I will solve this problem like usual.";

  const AUD_HEAD=[...HEAD,'task_id_copy','corrected_problem','annotator_solution'];
  const audit=[], pause=[];
  pending.forEach(r=>{
    const dup = truthy(r[iExact])||truthy(r[iNear]);
    const good= String(r[iFlag]).trim()===OK || String(r[iFlag]).trim()==='';
    if(!dup&&good){
      audit.push([...r,
        truncateValue(r[ix.task]),
        truncateValue((r[ix.cor]&&String(r[ix.cor]).trim().toUpperCase()!=='N/A')?r[ix.cor]:r[ix.ext]),
        truncateValue(r[ix.sol])
      ]);
    } else pause.push(r);
  });

  overwriteSheet(ss, CFG.SOL_AUDIT_SHEET, AUD_HEAD, audit);
  overwriteSheet(ss, CFG.SOL_PAUSE_SHEET, HEAD, pause);
}

/* ------------------------------------------------------------------ */
/*  U–Z override realignment  (Solutions Audit)                       */
/*  Keeps all six columns together:                                   */
/*    U task_id_copy                                                  */
/*    V corrected_problem (or extracted_problem)                      */
/*    W annotator_solution                                            */
/*    X checkbox / manual flag                                        */
/*    Y manual field (preserve)                                       */
/*    Z auditor name (preserve)                                       */
/* ------------------------------------------------------------------ */
function syncSolutionsOverrides() {
  const OV_START = 21;   // U
  const OV_COLS  = 6;    // U…Z

  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(CFG.SOL_AUDIT_SHEET);
  if (!sh) return;

  const last = sh.getLastRow();
  if (last < 2) return;

  /* -------- Old override block (U–Z) -------- */
  const old = sh.getRange(2, OV_START, last - 1, OV_COLS).getValues();
  const byId = new Map();                         // task_id_copy → old U–Z row
  old.forEach(r => { const k = String(r[0]).trim(); if (k) byId.set(k, r); });

  /* -------- Fresh sheet columns we need -------- */
  const colA = sh.getRange(2,  1, last - 1).getValues(); // task_id
  const colC = sh.getRange(2,  3, last - 1).getValues(); // extracted_problem
  const colI = sh.getRange(2,  9, last - 1).getValues(); // annotator_solution
  const colJ = sh.getRange(2, 10, last - 1).getValues(); // corrected_problem

  /* -------- Build new override block -------- */
  const block = [];

  for (let i = 0; i < last - 1; i++) {
    const id   = String(colA[i][0]).trim();
    const prev = byId.get(id) || Array(OV_COLS).fill('');

    const U = id;                                                   // always sync
    const V = prev[1] ||
              (colJ[i][0] && String(colJ[i][0]).trim().toUpperCase() !== 'N/A'
                 ? colJ[i][0]
                 : colC[i][0]);
    const W = prev[2] || colI[i][0];
    const X = prev[3] || '';                                        // preserve if exists
    const Y = prev[4] || '';                                        // preserve if exists
    const Z = prev[5] || '';                                        // preserve if exists

    block.push([truncateValue(U), truncateValue(V), truncateValue(W), X, Y, Z]);
  }

  /* -------- Write back U–Z in one shot -------- */
  sh.getRange(2, OV_START, block.length, OV_COLS).setValues(block);
}


/* =========================================================== */
/* UTIL to build corpus (Solutions & Extractions)              */
/* =========================================================== */
function loadCorpus(sh,idCols,txtCol){
  const V=sh.getDataRange().getValues(), H=V[0];
  const i1=H.indexOf(idCols[0]), i2=H.indexOf(idCols[1]), it=H.indexOf(txtCol);
  return V.slice(1).map(r=>({id1:norm(r[i1]),id2:norm(r[i2]),tok:tokens(canonical(r[it]))}));
}

/* =========================================================== */
/* onEdit: checkbox ✓ → full name                              */
/* =========================================================== */
function onEdit(e){
  const map={
    'Completed Extractions -> Audit for delivery':{ cb:30, name:31 },
    'Clean Solutions Audit':                       { cb:24, name:25 }
  };
  const cfg=map[e.range.getSheet().getName()]; if(!cfg) return;
  if(e.range.getColumn()!==cfg.cb) return;
  if(!e.range.isChecked())        return;
  const full=getFullName(Session.getActiveUser().getEmail()||'');
  if(full) e.range.getSheet().getRange(e.range.getRow(),cfg.name).setValue(full);
}
function getFullName(email){
  const local=email.split('@')[0];
  if(local.includes('.')){const [f,l]=local.split('.'); return `${cap(f)} ${cap(l)}`;}
  const m=local.match(/^([a-z])[_]?([a-z]+)/i); if(m) return `${cap(m[1])} ${cap(m[2])}`;
  return cap(local);
}
const cap=s=>s?s[0].toUpperCase()+s.slice(1):'';
