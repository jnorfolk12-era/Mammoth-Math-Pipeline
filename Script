/******************************************************************
 *  MASTER PIPELINE SCRIPT  v 5.6
 *  --------------------------------------------------------------
 *  • Truncates any string > 50 000 chars before writing to Sheets
 *
 *  Pipelines
 *  ① Completed Extractions
 *  ② Approved & Completed Solutions
 ******************************************************************/

/* ──────────────────────────────────────────────────────────── */
/*                       GLOBAL LIMIT                          */
const MAX_CELL_LENGTH = 50000;
const truncateValue  = v =>
  (typeof v === 'string' && v.length > MAX_CELL_LENGTH) ? v.slice(0, MAX_CELL_LENGTH) : v;
const truncateMatrix = M => M.map(r => r.map(truncateValue));

/* ──────────────────────────────────────────────────────────── */
/*                       CONFIGURATION                         */
const CFG = {
  /* Completed Extractions */
  CONNECTED_SHEET   : 'All Problems in Solutions - Ext',
  PENDING_SHEET     : 'Completed Extractions',
  CLEANED_SHEET     : 'Completed Extractions - Cleaned',
  AUDIT_RAW_SHEET   : 'Completed Extractions -> Audit (RAW)',
  AUDIT_VIEW_SHEET  : 'Completed Extractions -> Audit for delivery',
  SOLN_SHEET        : 'Completed Extractions -> Solutions',
  HOLD_SHEET        : 'Completed Extractions -> Holding',

  /* Approved & Completed Solutions */
  SOL_PENDING_SHEET : 'Approved and Completed Solutions - Ext',
  SOL_ALL_SHEET     : 'Delivered Solutions - Ext',
  SOL_CLEANED_SHEET : 'Approved and Completed Solutions - Cleaned',
  SOL_AUDIT_SHEET   : 'Clean Solutions Audit',
  SOL_PAUSE_SHEET   : 'Solutions -> Pause',

  /* Columns and thresholds */
  ALL_ID_COLS       : ['original_task_id', 'problem_id'],
  PENDING_ID_COLS   : ['task_id', 'problem_id'],
  TEXT_COL          : 'problem',
  PENDING_CHECKED_COL : null,   // set to header if you want a “checked” flag
  SIM_THRESHOLD       : 0.90
};

/* ──────────────────────────────────────────────────────────── */
/*                       MENU ENTRIES                          */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Task Tools')
    .addItem('Run Completed Extractions Pipeline', 'runAllExtractions')
    .addItem('Run Approved & Completed Solutions Pipeline', 'runSolutions')
    .addToUi();
}

/* ──────────────────────────────────────────────────────────── */
/*                  COMMON: REFRESH CONNECTED SHEETS           */
function refreshConnectedData() {
  SpreadsheetApp.enableBigQueryExecution();
  SpreadsheetApp.getActiveSpreadsheet().refreshAllDataSources();
  SpreadsheetApp.flush();
}

/* =========================================================== */
/* ①  COMPLETED EXTRACTIONS PIPELINE                           */
/* =========================================================== */
function runAllExtractions() {
  refreshConnectedData();
  cleanCompletedExtracts();
  syncOverrides();
  SpreadsheetApp.getUi().alert('✅ Completed Extractions pipeline complete!');
}

function cleanCompletedExtracts() {
  const ss = SpreadsheetApp.getActive();

  /* build corpus */
  const corpus = loadCorpus(
    ss.getSheetByName(CFG.CONNECTED_SHEET),
    CFG.ALL_ID_COLS,
    CFG.TEXT_COL
  );
  const corpusIds = new Set(
    corpus.flatMap(c => [c.id1, c.id2]).filter(Boolean)
  );
  const corpusTok = corpus.map(c => c.tok);

  /* load pending */
  const pSh   = ss.getSheetByName(CFG.PENDING_SHEET);
  const pVals = pSh.getDataRange().getValues();
  const pHead = pVals[0], pRows = pVals.slice(1);

  const col = h => {
    const idx = pHead.indexOf(h);
    if (idx === -1) throw `Missing column "${h}" in ${CFG.PENDING_SHEET}`;
    return idx;
  };
  const idx = {
    id1  : col(CFG.PENDING_ID_COLS[0]),
    id2  : col(CFG.PENDING_ID_COLS[1]),
    text : col(CFG.TEXT_COL),
    prob : col('problematic_task'),
    agree: col('model_solution_agreement')
  };
  const chkIdx = CFG.PENDING_CHECKED_COL ? col(CFG.PENDING_CHECKED_COL) : null;

  const head = [...pHead,
    'is_exact_duplicate_id',        // P
    'matching_ids',                 // Q
    'is_near_duplicate',            // R
    'nearest_task_id',              // S
    'similarity'                    // T
  ];

  const out = [];

  pRows.forEach((row, rIdx) => {
    if (chkIdx !== null && row[chkIdx]) {
      out.push([...row, '', '', '', '', '']);
      return;
    }

    /* exact duplicate */
    const matches = [];
    const id1 = normId(row[idx.id1]), id2 = normId(row[idx.id2]);
    if (id1 && corpusIds.has(id1)) matches.push(id1);
    if (id2 && corpusIds.has(id2)) matches.push(id2);
    const exact = matches.length > 0;

    /* near duplicate */
    const tok = tokens(row[idx.text]);
    let best = 0, bI = -1;
    corpusTok.forEach((t, i) => {
      const s = jaccard(tok, t);
      if (s > best) { best = s; bI = i; }
    });
    const near = best >= CFG.SIM_THRESHOLD;
    const nearestTask = near ? corpus[bI].id1 || '' : '';

    if (chkIdx !== null) pSh.getRange(rIdx + 2, chkIdx + 1).setValue(true);

    out.push([
      ...row,
      exact,
      matches.join(','),
      near,
      nearestTask,
      best.toFixed(3)
    ]);
  });

  overwriteSheet(ss, CFG.CLEANED_SHEET, head, out);
  partitionRows(ss, head, out);
}

function partitionRows(ss, head, rows) {
  const idx = h => head.indexOf(h);
  const iProb  = idx('problematic_task');
  const iAgree = idx('model_solution_agreement');
  const iExact = idx('is_exact_duplicate_id');
  const iNear  = idx('is_near_duplicate');

  const audit = [], soln = [], hold = [];

  rows.forEach(r => {
    const ok  = String(r[iProb]).trim() === 'No issues with task!';
    const dup = truthy(r[iExact]) || truthy(r[iNear]);

    if (ok && !dup && String(r[iAgree]).trim() === 'Yes')      audit.push(r);
    else if (ok && !dup && String(r[iAgree]).trim() !== 'Yes') soln.push(r);
    else                                                       hold.push(r);
  });

  writeRaw      (ss, CFG.AUDIT_RAW_SHEET, head, audit);
  ensureAuditView(ss, head);
  overwriteSheet(ss, CFG.SOLN_SHEET, head, soln);
  overwriteSheet(ss, CFG.HOLD_SHEET, head, hold);
}

function syncOverrides() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(CFG.AUDIT_VIEW_SHEET);
  if (!sh) return;

  const last = sh.getLastRow();
  if (last < 2) return;

  const task = sh.getRange(2, 1,  last-1).getValues(); // A
  const prob = sh.getRange(2, 2,  last-1).getValues(); // B
  const corr = sh.getRange(2,13,  last-1).getValues(); // M
  const sol  = sh.getRange(2,17,  last-1).getValues(); // Q

  const AA = sh.getRange(2,27,last-1).getValues();     // AA
  const AB = sh.getRange(2,28,last-1).getValues();     // AB
  const AC = sh.getRange(2,29,last-1).getValues();     // AC

  let wA=false,wB=false,wC=false;

  const newAA = AA.map((r,i)=>{
    if(!r[0] && task[i][0]!==''){ wA=true; return [truncateValue(task[i][0])];}
    return [r[0]];
  });
  const newAB = AB.map((r,i)=>{
    if(!r[0]){
      const m=String(corr[i][0]||'').trim();
      const v=(m && m.toUpperCase()!=='N/A') ? m : prob[i][0];
      if(v!=='') wB=true;
      return [truncateValue(v)];
    }
    return [r[0]];
  });
  const newAC = AC.map((r,i)=>{
    if(!r[0] && sol[i][0]!==''){ wC=true; return [truncateValue(sol[i][0])];}
    return [r[0]];
  });

  if(wA) sh.getRange(2,27,newAA.length,1).setValues(newAA);
  if(wB) sh.getRange(2,28,newAB.length,1).setValues(newAB);
  if(wC) sh.getRange(2,29,newAC.length,1).setValues(newAC);
}

function ensureAuditView(ss, headers) {
  const colCount = headers.length;
  const view = ss.getSheetByName(CFG.AUDIT_VIEW_SHEET) || ss.insertSheet(CFG.AUDIT_VIEW_SHEET);
  view.showSheet();

  view.getRange(1, 1, 1, colCount).setValues([truncateMatrix([headers])[0]]);
  view.getRange(2, 1, view.getMaxRows() - 1, colCount).clearContent();

  const rawEsc = CFG.AUDIT_RAW_SHEET.replace(/'/g,"''");
  const rng    = `'${rawEsc}'!A2:${String.fromCharCode(64 + colCount)}`;
  view.getRange('A2').setFormula(`=FILTER(${rng}, LEN('${rawEsc}'!A2:A))`);
  view.setFrozenRows(1);
}

/* =========================================================== */
/* ②  APPROVED & COMPLETED SOLUTIONS PIPELINE                  */
/* =========================================================== */
function runSolutions() {
  refreshConnectedData();
  cleanApprovedCompletedSolutions();
  SpreadsheetApp.getUi().alert('✅ Approved & Completed Solutions pipeline complete!');
}

function cleanApprovedCompletedSolutions() {
  const ss = SpreadsheetApp.getActive();

  /* ALL reference */
  const allSh = ss.getSheetByName(CFG.SOL_ALL_SHEET);
  if (!allSh) throw `Sheet "${CFG.SOL_ALL_SHEET}" not found`;
  const allV  = allSh.getDataRange().getValues();
  const hA    = allV[0], rA = allV.slice(1);
  const ia = { task:hA.indexOf('task_id'), pid:hA.indexOf('problem_id'), prob:hA.indexOf('problem') };
  const allTok = rA.map(r=>tokens(canonical(r[ia.prob])));
  const allIds = new Set(rA.flatMap(r=>[normId(r[ia.task]), normId(r[ia.pid])]).filter(Boolean));

  /* PENDING rows */
  const pSh = ss.getSheetByName(CFG.SOL_PENDING_SHEET);
  if (!pSh) throw `Sheet "${CFG.SOL_PENDING_SHEET}" not found`;
  const pV  = pSh.getDataRange().getValues();
  const hP  = pV[0], rP = pV.slice(1);
  const ip  = {
    task : hP.indexOf('task_id'),            // A
    pid  : hP.indexOf('problem_id'),         // B
    extp : hP.indexOf('extracted_problem'),  // C
    sol  : hP.indexOf('annotator_solution'), // I
    corr : hP.indexOf('corrected_problem'),  // J
    pflag: hP.indexOf('problematic_task')    // K (or actual index)
  };

  /* Build Cleaned dataset */
  const cleanedHead = [...hP,
    'is_exact_duplicate_id','matching_ids',
    'is_near_duplicate','nearest_task_id','similarity'];

  const cleanedRows = rP.map(r=>{
    /* exact dup */
    const matches=[];
    const tID=normId(r[ip.task]), pID=normId(r[ip.pid]);
    if(tID&&allIds.has(tID)) matches.push(tID);
    if(pID&&allIds.has(pID)) matches.push(pID);
    const exact = matches.length>0;

    /* near dup */
    const tok = tokens(canonical(r[ip.extp]));
    let best=0,bI=-1;
    allTok.forEach((t,i)=>{const s=jaccard(tok,t); if(s>best){best=s;bI=i;}});
    const near    = best >= CFG.SIM_THRESHOLD;
    const nearest = near ? normId(rA[bI][ia.task]) : '';

    return [...r, exact, matches.join(','), near, nearest, best.toFixed(3)];
  });

  overwriteSheet(ss, CFG.SOL_CLEANED_SHEET, cleanedHead, cleanedRows);

  /* Partition -> Audit / Pause */
  const iExact = cleanedHead.indexOf('is_exact_duplicate_id');
  const iNear  = cleanedHead.indexOf('is_near_duplicate');
  const iFlag  = cleanedHead.indexOf('problematic_task');
  const target = "No issues with problem! I will solve this problem like usual.";

  const auditHead = [...cleanedHead, 'task_id_copy', 'corrected_problem', 'annotator_solution'];
  const audit=[], pause=[];

  cleanedRows.forEach(r=>{
    const flag = String(r[iFlag]).trim();
    const msgOK = flag === target || flag === '';
    const dup   = truthy(r[iExact]) || truthy(r[iNear]);

    if (!dup && msgOK) {
      audit.push([
        ...r,
        truncateValue(r[ip.task]),
        truncateValue(
          (r[ip.corr] && String(r[ip.corr]).trim().toUpperCase() !== 'N/A')
            ? r[ip.corr] : r[ip.extp]
        ),
        truncateValue(r[ip.sol])
      ]);
    } else {
      pause.push(r);
    }
  });

  overwriteSheet(ss, CFG.SOL_AUDIT_SHEET, auditHead, audit);
  overwriteSheet(ss, CFG.SOL_PAUSE_SHEET, cleanedHead, pause);
}

/* =========================================================== */
/*                     GENERIC SHEET HELPERS                   */
/* =========================================================== */
function overwriteSheet(ss, name, headers, rows) {
  const sh = ss.getSheetByName(name) || ss.insertSheet(name);
  sh.showSheet();
  sh.clearContents();
  if (rows.length) {
    sh.getRange(1, 1, 1, headers.length)
      .setValues([truncateMatrix([headers])[0]]);
    sh.getRange(2, 1, rows.length, headers.length)
      .setValues(truncateMatrix(rows));
  } else {
    sh.getRange(1,1).setValue('No rows');
  }
  sh.setFrozenRows(1);
}
function writeRaw(ss,name,hdr,rows){
  const raw=ss.getSheetByName(name)||ss.insertSheet(name);
  raw.hideSheet(); raw.clearContents();
  if(rows.length){
    raw.getRange(1,1,1,hdr.length).setValues([truncateMatrix([hdr])[0]]);
    raw.getRange(2,1,rows.length,hdr.length).setValues(truncateMatrix(rows));
  }
}

/* =========================================================== */
/*                          UTILITIES                          */
/* =========================================================== */
function loadCorpus(sh, idCols, txtCol){
  const V=sh.getDataRange().getValues(), H=V[0];
  const i1=H.indexOf(idCols[0]), i2=H.indexOf(idCols[1]), t=H.indexOf(txtCol);
  return V.slice(1).map(r=>({
    id1:normId(r[i1]),
    id2:normId(r[i2]),
    tok:tokens(canonical(r[t]))
  }));
}
const normId=v=>{const s=String(v??'').trim();return s&&!/^(null|n\/?a)$/i.test(s)?s:'';};
const canonical=t=>String(t||'').trim().toLowerCase()
  .replace(/’/g,"'").replace(/[“”]/g,'"')
  .replace(/\u2212/g,'-').replace(/\xa0/g,' ')
  .replace(/[^\w\s]/g,' ').replace(/\s+/g,' ');
const tokens=t=>canonical(t).split(' ').filter(w=>w.length>=3);
const jaccard=(A,B)=>{const a=new Set(A), b=new Set(B);
  const i=[...a].filter(x=>b.has(x)).length;
  return i/(a.size+b.size-i||1);};
const truthy=v=>v===true||v==='TRUE'||v==='true';
