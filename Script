/******************************************************************
 *  MASTER PIPELINE v 7.2   (2025-07-12)
 *  --------------------------------------------------------------
 *  • overwriteSheet rewrites only A…owned cols – manual edits safe
 *  • purgeBlankRows() deletes “ghost” rows in one pass
 *  • Extractions AA-AF and Solutions U-Z override blocks realign
 *  • Columns V, W, Y, Z always preserved & repositioned
 *  • onEdit checkbox ✓ → full name (AD→AE, X→Z)
 *  • 50 000-char truncator to avoid cell-size errors
 ******************************************************************/

/* ───────── GLOBALS ───────── */
const MAX_CELL = 50000;
const truncVal = v => (typeof v === 'string' && v.length > MAX_CELL) ? v.slice(0, MAX_CELL) : v;
const truncMat = m => m.map(r => r.map(truncVal));
const trunc = truncVal;            // ✅  alias used by sync* functions


const CFG = {
  /* Extractions */
  CONNECTED_SHEET   : 'All Problems in Solutions - Ext',
  PENDING_SHEET     : 'Completed Extractions',
  CLEANED_SHEET     : 'Completed Extractions - Cleaned',
  AUDIT_RAW_SHEET   : 'Completed Extractions -> Audit (RAW)',
  AUDIT_VIEW_SHEET  : 'Completed Extractions -> Audit for delivery',
  SOLN_SHEET        : 'Completed Extractions -> Solutions',
  HOLD_SHEET        : 'Completed Extractions -> Holding',

  /* Solutions */
  SOL_PENDING_SHEET : 'Approved and Completed Solutions - Ext',
  SOL_ALL_SHEET     : 'Delivered Solutions - Ext',
  SOL_CLEANED_SHEET : 'Approved and Completed Solutions - Cleaned',
  SOL_AUDIT_SHEET   : 'Clean Solutions Audit',
  SOL_PAUSE_SHEET   : 'Solutions -> Pause',

  /* Shared */
  TEXT_COL      : 'problem',
  SIM_THRESHOLD : 0.90
};

/* ───────── MENU ───────── */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Task Tools')
    .addItem('Run Completed Extractions Pipeline', 'runAllExtractions')
    .addItem('Run Approved & Completed Solutions Pipeline', 'runSolutions')
    .addToUi();
}

/* ───────── REFRESH ───────── */
function refreshConnectedData() {
  SpreadsheetApp.enableBigQueryExecution();
  SpreadsheetApp.getActiveSpreadsheet().refreshAllDataSources();
  SpreadsheetApp.flush();
}

/* =========================================================== */
/*  0  Shared helpers                                           */
/* =========================================================== */
function overwriteSheet(ss, name, headers, rows) {
  const sh = ss.getSheetByName(name) || ss.insertSheet(name);
  const wasHidden = sh.isSheetHidden();

  let owned = headers.length;
  if (name === CFG.AUDIT_VIEW_SHEET) owned = 25; // A…Y
  if (name === CFG.SOL_AUDIT_SHEET)  owned = 20; // A…T

  if (sh.getLastRow() > 1) sh.getRange(2, 1, sh.getLastRow() - 1, owned).clearContent();
  sh.getRange(1, 1, 1, headers.length).setValues([truncMat([headers])[0]]);

  if (rows.length) {
    const trimmed = rows.map(r => r.slice(0, owned));
    sh.getRange(2, 1, trimmed.length, owned).setValues(truncMat(trimmed));
  } else {
    sh.getRange(2, 1).setValue('No rows');
  }
  sh.setFrozenRows(1);
  if (wasHidden) sh.hideSheet();
}

function writeRaw(ss, name, headers, rows) {
  const raw = ss.getSheetByName(name) || ss.insertSheet(name);
  raw.clearContents();
  if (rows.length) {
    raw.getRange(1, 1, 1, headers.length).setValues([truncMat([headers])[0]]);
    raw.getRange(2, 1, rows.length, headers.length).setValues(truncMat(rows));
  }
  raw.hideSheet();
}

function purgeBlankRows(sheetName, keyCol, ownedCols) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sh) return;
  const n = sh.getLastRow() - 1; if (n < 1) return;

  const col = sh.getRange(2, keyCol, n).getValues();
  const blanks = [];
  col.forEach((v, i) => { if (String(v[0]).trim() === '') blanks.push(i + 2); });
  if (blanks.length) sh.deleteRows(blanks[0], blanks.length);
}

/* text utils */
const canon = t => String(t||'').trim().toLowerCase()
  .replace(/’/g,"'").replace(/[“”]/g,'"')
  .replace(/\u2212/g,'-').replace(/\xa0/g,' ')
  .replace(/[^\w\s]/g,' ').replace(/\s+/g,' ');
const tokens = t => canon(t).split(' ').filter(w=>w.length>=3);
const norm   = v => { const s=String(v??'').trim(); return s && !/^(null|n\/?a)$/i.test(s) ? s : ''; };
const jacc   = (A,B) => {const a=new Set(A),b=new Set(B);const i=[...a].filter(x=>b.has(x)).length;return i/(a.size+b.size-i||1);};
const truthy = v => v===true||v==='TRUE'||v==='true';
function loadCorpus(sh,id1,id2,txt){
  const V=sh.getDataRange().getValues(),H=V[0];
  const i1=H.indexOf(id1),i2=H.indexOf(id2),it=H.indexOf(txt);
  return V.slice(1).map(r=>({id1:norm(r[i1]),id2:norm(r[i2]),tok:tokens(canon(r[it]))}));
}

/* =========================================================== */
/* ①  Completed Extractions Pipeline                            */
/* =========================================================== */
function runAllExtractions() {
  refreshConnectedData();
  cleanCompletedExtracts();
  purgeBlankRows(CFG.AUDIT_VIEW_SHEET, 1, 25);
  syncOverrides();
  SpreadsheetApp.getUi().alert('✅ Completed Extractions pipeline complete!');
}

function cleanCompletedExtracts() {
  const ss = SpreadsheetApp.getActive();

  /* corpus = all Solutions problems */
  const corpus = loadCorpus(
    ss.getSheetByName(CFG.CONNECTED_SHEET),
    'original_task_id','problem_id',CFG.TEXT_COL
  );
  const ids = new Set(corpus.flatMap(c=>[c.id1,c.id2]).filter(Boolean));
  const tok = corpus.map(c=>c.tok);

  /* pending */
  const pSh = ss.getSheetByName(CFG.PENDING_SHEET);
  const V = pSh.getDataRange().getValues(), H = V[0], R = V.slice(1);
  const ix={task:H.indexOf('task_id'), pid:H.indexOf('problem_id'),
            prob:H.indexOf('problem'),
            flag:H.indexOf('problematic_task'),
            agree:H.indexOf('model_solution_agreement')};

  const HEAD=[...H,'is_exact_duplicate_id','matching_ids','is_near_duplicate','nearest_task_id','similarity'];
  const out=[];
  R.forEach(r=>{
    const matches=[], tID=norm(r[ix.task]), pID=norm(r[ix.pid]);
    if(tID&&ids.has(tID)) matches.push(tID);
    if(pID&&ids.has(pID)) matches.push(pID);
    const exact=matches.length>0;

    const t=tokens(r[ix.prob]), sims=tok.map(x=>jacc(t,x));
    const best=Math.max(...sims), idx=sims.indexOf(best);
    const near=best>=CFG.SIM_THRESHOLD, nearest=near?corpus[idx].id1:'';

    out.push([...r, exact, matches.join(','), near, nearest, best.toFixed(3)]);
  });

  overwriteSheet(ss, CFG.CLEANED_SHEET, HEAD, out);

  /* partition */
  const iExact=HEAD.indexOf('is_exact_duplicate_id'),
        iNear =HEAD.indexOf('is_near_duplicate'),
        iFlag =HEAD.indexOf('problematic_task'),
        iAgree=HEAD.indexOf('model_solution_agreement');
  const OK='No issues with task!';
  const audit=[], soln=[], hold=[];
  out.forEach(r=>{
    const dup = truthy(r[iExact])||truthy(r[iNear]);
    const good=String(r[iFlag]).trim()===OK;
    const agree=String(r[iAgree]).trim()==='Yes';
    if(good&&!dup&&agree) audit.push(r);
    else if(good&&!dup)   soln.push(r);
    else                  hold.push(r);
  });

  writeRaw      (ss, CFG.AUDIT_RAW_SHEET, HEAD, audit);
  ensureAuditView(ss, HEAD);
  overwriteSheet(ss, CFG.SOLN_SHEET, HEAD, soln);
  overwriteSheet(ss, CFG.HOLD_SHEET, HEAD, hold);
}

function syncOverrides() {
  const sh=SpreadsheetApp.getActive().getSheetByName(CFG.AUDIT_VIEW_SHEET);
  if(!sh) return;
  const n=sh.getLastRow()-1; if(n<1) return;

  const old=sh.getRange(2,27,n,6).getValues(); // AA-AF
  const map=new Map(); old.forEach(r=>{const k=String(r[0]).trim();if(k)map.set(k,r);});

  const id = sh.getRange(2,1,n).getValues(),
        pr = sh.getRange(2,2,n).getValues(),
        cp = sh.getRange(2,13,n).getValues(),
        mp = sh.getRange(2,17,n).getValues();

  const blk=[];
  for(let i=0;i<n;i++){
    const key=String(id[i][0]).trim(), prev=map.get(key)||Array(6).fill('');
    blk.push([
      key,
      prev[1]||(cp[i][0]&&String(cp[i][0]).trim().toUpperCase()!=='N/A'?cp[i][0]:pr[i][0]),
      prev[2]||mp[i][0],
      prev[3]||'', prev[4]||'', prev[5]||''
    ].map(trunc));
  }
  sh.getRange(2,27,n,6).setValues(blk);
}

function ensureAuditView(ss,HEAD){
  const n=HEAD.length;
  const view=ss.getSheetByName(CFG.AUDIT_VIEW_SHEET)||ss.insertSheet(CFG.AUDIT_VIEW_SHEET);
  view.showSheet();
  view.getRange(1,1,1,n).setValues([truncMat([HEAD])[0]]);
  if(view.getLastRow()>1) view.getRange(2,1,view.getLastRow()-1,25).clearContent(); // A-Y
  const esc=CFG.AUDIT_RAW_SHEET.replace(/'/g,"''");
  view.getRange('A2').setFormula(`=FILTER('${esc}'!A2:${String.fromCharCode(64+n)},LEN('${esc}'!A2:A))`);
  view.setFrozenRows(1);
}

/* =========================================================== */
/* ②  Approved & Completed Solutions Pipeline                   */
/* =========================================================== */
function runSolutions() {
  refreshConnectedData();
  cleanApprovedCompletedSolutions();
  purgeBlankRows(CFG.SOL_AUDIT_SHEET, 1, 20);
  syncSolutionsOverrides();
  SpreadsheetApp.getUi().alert('✅ Approved & Completed Solutions pipeline complete!');
}

function cleanApprovedCompletedSolutions() {
  const ss=SpreadsheetApp.getActive();

  /* corpus */
  const corpus=loadCorpus(ss.getSheetByName(CFG.SOL_ALL_SHEET),'task_id','problem_id',CFG.TEXT_COL);
  const ids=new Set(corpus.flatMap(c=>[c.id1,c.id2]).filter(Boolean));
  const tok=corpus.map(c=>c.tok);

  /* pending */
  const pSh=ss.getSheetByName(CFG.SOL_PENDING_SHEET);
  const V=pSh.getDataRange().getValues(), H=V[0], R=V.slice(1);
  const ix={task:H.indexOf('task_id'), pid:H.indexOf('problem_id'),
            ext:H.indexOf('extracted_problem'),
            sol:H.indexOf('annotator_solution'),
            cor:H.indexOf('corrected_problem'),
            flag:H.indexOf('problematic_task')};

  const HEAD=[...H,'is_exact_duplicate_id','matching_ids','is_near_duplicate','nearest_task_id','similarity'];
  const out=[];
  R.forEach(r=>{
    const matches=[], tID=norm(r[ix.task]), pID=norm(r[ix.pid]);
    if(tID&&ids.has(tID)) matches.push(tID);
    if(pID&&ids.has(pID)) matches.push(pID);
    const exact=matches.length>0;

    const t=tokens(r[ix.ext]), sims=tok.map(x=>jacc(t,x));
    const best=Math.max(...sims), idx=sims.indexOf(best);
    const near=best>=CFG.SIM_THRESHOLD, nearest=near?corpus[idx].id1:'';

    out.push([...r, exact, matches.join(','), near, nearest, best.toFixed(3)]);
  });

  overwriteSheet(ss, CFG.SOL_CLEANED_SHEET, HEAD, out);

  /* partition */
  const iExact=HEAD.indexOf('is_exact_duplicate_id'),
        iNear =HEAD.indexOf('is_near_duplicate'),
        iFlag =HEAD.indexOf('problematic_task');
  const OK="No issues with problem! I will solve this problem like usual.";

  const AUD=[...HEAD,'task_id_copy','corrected_problem','annotator_solution'];
  const audit=[], pause=[];
  out.forEach(r=>{
    const dup = truthy(r[iExact])||truthy(r[iNear]);
    const good= String(r[iFlag]).trim()===OK || String(r[iFlag]).trim()==='';
    if(!dup&&good){
      audit.push([...r,
        trunc(r[ix.task]),
        trunc((r[ix.cor]&&String(r[ix.cor]).trim().toUpperCase()!=='N/A')?r[ix.cor]:r[ix.ext]),
        trunc(r[ix.sol])
      ]);
    } else pause.push(r);
  });

  overwriteSheet(ss, CFG.SOL_AUDIT_SHEET, AUD, audit);
  overwriteSheet(ss, CFG.SOL_PAUSE_SHEET, HEAD, pause);
}

/* ------------------------------------------------------------------ */
/*  U–Z override realignment  (Solutions Audit)                       */
/*  W now comes from column H (index 8)                               */
/* ------------------------------------------------------------------ */
function syncSolutionsOverrides() {
  const OV_START = 21;   // U
  const OV_COLS  = 6;    // U…Z

  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(CFG.SOL_AUDIT_SHEET);
  if (!sh) return;

  const last = sh.getLastRow();
  if (last < 2) return;

  /* old override block */
  const old = sh.getRange(2, OV_START, last - 1, OV_COLS).getValues();
  const byId = new Map();
  old.forEach(r => { const k = String(r[0]).trim(); if (k) byId.set(k, r); });

  /* fresh sheet columns we need */
  const colA = sh.getRange(2,  1, last - 1).getValues(); // task_id
  const colC = sh.getRange(2,  3, last - 1).getValues(); // extracted_problem
  const colH = sh.getRange(2,  8, last - 1).getValues(); // *** column H ***
  const colJ = sh.getRange(2, 10, last - 1).getValues(); // corrected_problem

  const block = [];

  for (let i = 0; i < last - 1; i++) {
    const id   = String(colA[i][0]).trim();
    const prev = byId.get(id) || Array(OV_COLS).fill('');

    const U = id;
    const V = prev[1] ||
              (colJ[i][0] && String(colJ[i][0]).trim().toUpperCase() !== 'N/A'
                 ? colJ[i][0]
                 : colC[i][0]);
    const W = prev[2] || colH[i][0];          // ← now uses column H
    const X = prev[3] || '';
    const Y = prev[4] || '';
    const Z = prev[5] || '';

    block.push([trunc(U), trunc(V), trunc(W), X, Y, Z]);
  }

  sh.getRange(2, OV_START, block.length, OV_COLS).setValues(block);
}


/* =========================================================== */
/*  onEdit checkbox ✓ → full name                              */
/* =========================================================== */
function onEdit(e){
  const cfg={
    'Completed Extractions -> Audit for delivery':{ cb:30, name:31 },
    'Clean Solutions Audit':                       { cb:24, name:25 }
  }[e.range.getSheet().getName()];
  if(!cfg||e.range.getColumn()!==cfg.cb||!e.range.isChecked()) return;
  const full=fmtName(Session.getActiveUser().getEmail()||'');
  if(full) e.range.getSheet().getRange(e.range.getRow(),cfg.name).setValue(full);
}
const fmtName=email=>{
  const local=email.split('@')[0];
  if(local.includes('.')){const [f,l]=local.split('.'); return `${cap(f)} ${cap(l)}`;}
  const m=local.match(/^([a-z])[_]?([a-z]+)/i); if(m) return `${cap(m[1])} ${cap(m[2])}`;
  return cap(local);
};
const cap=s=>s?s[0].toUpperCase()+s.slice(1):'';
